{"pages":[],"posts":[{"title":"OS学习笔记","text":"用于记录OS学习，参考资料为ostep中文版和北京交通大学公开课","link":"/2019/11/02/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/30/hello-world/"},{"title":"磁盘调度算法","text":"FCFS,SSTF,SCAN,CSCAN算法用C语言实现FCFS,SSTF,SCAN,CSCAN算法，每次的序列及起始位置均随机生成，同时将每次访问时的状态变化写入文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;#define MaxSize 9#define flag 1struct re{ double disNow; int visitNow; double AverDis;}Record[MaxSize+1];void WriteText(int *Request,const char* method){ FILE *fp=fopen(\"disc.txt\",\"a\"); fprintf(fp,\"%s\\n\",method); fprintf(fp,\"磁盘访问序列:\\n\"); for(int i=0;i&lt;MaxSize;i++){ if(i==0) fprintf(fp,\"%d\",Request[i]); else fprintf(fp,\" %d\",Request[i]); } fprintf(fp,\"\\n\"); for(int Pos=0;Pos&lt;MaxSize+1;Pos++){ fprintf(fp,\"%-5.d%-5.lf%-5.2lf\\n\",Record[Pos].visitNow,Record[Pos].disNow,Record[Pos].AverDis); } fprintf(fp,\"\\n\\n\"); fclose(fp);}void Init(int *Request,int *TrackNow){ srand(time(NULL)); for(int i=0;i&lt;=MaxSize;i++){ Request[i]=rand()%500; } (*TrackNow)=rand()%100+100;}void FreshRecord(){ for(int i=0;i&lt;MaxSize;i++){ Record[i].visitNow=-1; Record[i].disNow=0; Record[i].AverDis=0; }}void InsertNode(int visit,double dis,int Pos){ Record[Pos].visitNow=visit; Record[Pos].disNow=dis; if(Pos==0) Record[Pos].AverDis=0; else Record[Pos].AverDis=dis/Pos;}void UpdateData(double *MovDistant,int *TrackNow,int *Pos,int index){ (*MovDistant)+=abs(index-(*TrackNow)); (*TrackNow)=index; InsertNode(*TrackNow,*MovDistant,(*Pos)++);}void Quick_Sort(int *Req,int left,int right){ if(left&gt;=right){ return; } int i=left; int j=right; int key=Req[left]; while(i&lt;j){ while(i&lt;j&amp;&amp;key&lt;=Req[j]){ j--; } Req[i]=Req[j]; while(i&lt;j&amp;&amp;key&gt;=Req[i]){ i++; } Req[j]=Req[i]; } Req[i]=key; Quick_Sort(Req,left,i-1); Quick_Sort(Req,i+1,right);}int FindDiv(int *Request,int TrackNow){ for(int i=0;i&lt;MaxSize-1;i++){ if(Request[i]&lt;TrackNow&amp;&amp;Request[i+1]&gt;=TrackNow) return i; } return MaxSize;}int Binary_Search(int *Request,int low,int high,int key){ int mid; if(key&gt;=Request[high]) return high; else if(key&lt;=Request[low]) return low; while(high-low&gt;1){ mid=(low+high)/2; if(Request[mid]&gt;key) high=mid; else low=mid; } return (Request[low]-key)&gt;(Request[high]-key)?high:low;}void FCFS(int *Request,int TrackNow){ int Pos=0; double MovDistant=0; InsertNode(TrackNow,MovDistant,Pos++); for(int i=0;i&lt;MaxSize;i++){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } printf(\"FCFS Success\\n\");}void SSTF(int *Request,int TrackNow){ int Pos=0; double MovDistant=0; InsertNode(TrackNow,MovDistant,Pos++); Quick_Sort(Request,0,MaxSize-1); int Point=Binary_Search(Request,0,MaxSize-1,TrackNow); UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[Point]); int left,right; for(left=Point-1,right=Point+1;right&lt;MaxSize&amp;&amp;left&gt;=0;){ /*while(Req[left]==-1&amp;&amp;left&gt;=0){ left--; } if(left&lt;0) break; while(Req[right]==-1&amp;&amp;right&lt;MaxSize){ right--; } if(right&gt;=MaxSize) break;*/ if(abs(Request[left]-TrackNow)&gt;abs(Request[right]-TrackNow)){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[right]); right++; } else{ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[left]); left--; } } while(left&gt;=0){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[left--]); } while(right&lt;MaxSize){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[right++]); } printf(\"SSTF Success\\n\");}void SCAN(int *Request,int TrackNow){ int Pos=0; double MovDistant=0; InsertNode(TrackNow,MovDistant,Pos++); Quick_Sort(Request,0,MaxSize-1); int Point=FindDiv(Request,TrackNow);//可优化 if(flag==1){ //优先向外圈还是内圈，1进外圈，0进内圈 for(int i=Point+1;i&lt;MaxSize;i++){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } for(int i=Point;i&gt;=0;i--){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } } else{ for(int i=Point;i&gt;=0;i--){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } for(int i=Point+1;i&lt;MaxSize;i++){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } } printf(\"SCAN Success\\n\");}void CSCAN(int *Request,int TrackNow){ int Pos=0; double MovDistant=0; InsertNode(TrackNow,MovDistant,Pos++); Quick_Sort(Request,0,MaxSize-1); int Point=FindDiv(Request,TrackNow);//可优化 if(flag==1){ //优先向外圈还是内圈，1进外圈，0进内圈 for(int i=Point+1;i&lt;MaxSize;i++){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } for(int i=0;i&lt;=Point;i++){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } } else{ for(int i=Point;i&gt;=0;i--){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } for(int i=MaxSize-1;i&gt;Point;i--){ UpdateData(&amp;MovDistant,&amp;TrackNow,&amp;Pos,Request[i]); } } printf(\"CSCAN Success\\n\"); }int main(){ int TrackNow; int *Request=(int *)malloc(MaxSize*sizeof(int)); Init_test(Request,&amp;TrackNow); FreshRecord(); FCFS(Request,TrackNow); WriteText(Request,\"FCFS\"); FreshRecord(); SSTF(Request,TrackNow); WriteText(Request,\"SSTF\"); FreshRecord(); SCAN(Request,TrackNow); WriteText(Request,\"SCAN\"); FreshRecord(); CSCAN(Request,TrackNow); WriteText(Request,\"CSCAN\"); FreshRecord(); free(Request);}","link":"/2019/11/16/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"},{"title":"进程管理","text":"","link":"/2019/11/02/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}],"tags":[],"categories":[]}